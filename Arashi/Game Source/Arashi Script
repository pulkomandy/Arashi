/*	Copyright:			Arashi 1.1		Copyright ©1993, Project STORM Team		This file is freely distributable,		but the parser and compiler for		it may only be used along with the		Arashi game. For permission to use		the compiler or parts of it for other		things, please request permission from						Juri Munkki			internet:	jmunkki@hut.fi			applelink:	sf0010*/FileScript=1	//	Reading from a file. (In case you are interested.)level 1		//	Starting from level 1, use the following rules:	AllowPracticeRestart=	Level % 2	AllowArcadeRestart	=	Level % 2	FlipperProb		=	1 + SubLevel / 15	FlipperCount	=	4 + SubLevel / 3 + Level / 8 - PulsarCount / 3 max 16	FlipperRot		=	(4 + Level/1.5) ^ 0.7 max 12	FlipperSpeed	= 	(1.0 + Level / 12) ^ 0.3	SpikerProb		=	(0.5 + SubLevel / 32) * (SubLevel > 3)	SpikeStart		=	DEPTH - ((SubLevel - 2) * DEPTH / 15 min 0)	SpikeTop		=	DEPTH * 0.1	SpikerSpeed		=	1 + Level / 40 max 2.5		EndTimer		=	3.2 / Level max 1.5	BoredomCount	=	2 + Level / 10 max 7	BoredProb		=	1.0 + Level / 32	FlipTankCount	=	(SubLevel - 1) ^ 0.7 - FuseTankCount / 2	FlipTankSpeed	=	(1.0 + Level / 12) ^ 0.4	FlipTankProb	=	0.3 + SubLevel / 20	level 11	FuseCount		=	2	FuseProb		=	0.5 + SubLevel / 15	FuseWarpP		=	Level / 100 max 0.5	FusePlayerPlus	=	Level / 40 max 0.9	level 16	SpikeStart		=	DEPTH - ((SubLevel - 2) * DEPTH / 15 min 0)	SpikerProb		=	(0.5 + SubLevel / 32) * (SubLevel > 1)	level 17	FuseCount		=	0	PulsarProb		=	0.7 + SubLevel / 20	PulsarCount		=	4 + SubLevel / 5 + Level / 10 max 12	PulsarRot		=	(4 + Level/2) ^ 0.6 max 11	PulsarSpeed		=	(Level / 20) ^ 0.3	PulsarTime		=	20 - Level / 20 min 5level 19	FuseCount		=	(Level / 3) ^ 0.7 max 6	AllowArcadeRestart	=	(Level % 2) < 1level 30	ShotPower			=	3	AllowArcadeRestart	=	(Level % 2)	level 33	FuseTankCount	=	SubLevel ^ 0.3 + 2 - PulsarTankCount / 2	FuseTankSpeed	=	(1.0 + Level / 12) ^ 0.4	FuseTankProb	=	0.3 + SubLevel / 20level 35	AllowArcadeRestart	=	(Level % 4) < 1	level 40	PulsarTankCount	=	SubLevel ^ 0.3 + 2	PulsarTankSpeed	=	(1.0 + Level / 12) ^ 0.4	PulsarTankProb	=	0.3 + SubLevel / 20level 47	AllowArcadeRestart	=	(Level % 2)level 51	AllowArcadeRestart	=	(Level % 4) < 1	level 63	AllowArcadeRestart	=	(Level % 2)	level 67	AllowArcadeRestart	=	((Level-65) % 8) < 1	level 82	AllowArcadeRestart	=	0		level 32000	//	We should never need to go past this point/* Finally, some instructions on how to modify this file:Here's a short grammar of the language. It should be pretty obvious for anyonewith a little background in grammars.Items in braces can be repeated statement	->	level n				variable = comparecompare		->	minmax { = minmax }				minmax { > minmax }				minmax { < minmax }minmax		->	expr { min expr }				expr { max expr }expr		->	term { + term }				term { - term }term		->	power { * power }				power { / power }				power { % power }power		->	factor { ^ factor }factor		->	(compare)				-factor				factor				+factor				variable				constant				function1 factor				function0functions with no parameters: (function0)		randomfunctions with one parameter: (function1)		| 		(abs)		sin		cos		int		roundkeywords:		level	*********************	*	How it works	*	*********************The idea is that you define variables and that new lines inthe script will replace old lines. For a certain level, onlythose definitions that appear before the next greater 'level'statement will be used to define that level.Order of evaluation is unspecified and there are no guaranteesthat variables will have reasonable values unless they areinitialized. If a circular reference is encountered, an oldvalue of a looped variable will be used to get out of the loop.For instance:	a = b	b = a + 1	If we evaluate a, we usually get 1 on the first round. This isbecause most variables are initialized to 0. If we execute itagain, we get 2 etc. If, instead we evaluate b, we get 1, butthe value of a will be 0. I hope this is confusing enough sothat you will avoid circular references. Let's just say thatthey are not very useful, but they do not cause problems.The order of evaluation is on a "need to know basis". I guessit's called intelligent recalculation in spreadsheet programs.Let's look at it with a short example:	a = 10	b = a + 20	c = 30	d = b + a	If we then evaluate d, the system will try to evaluate b, noticethat b requires a to be defined, so it evaluates a and then b. Itthen sees a again, but notices that it has been evaluated alreadyand uses the old value. c does not get evaluated at all.Let's look at something more complicated:	level 1			b = a		a = 1		a = 2	level 16			a = 3From levels 1 to 15, b will evaluate to 2, because that's the lastdefinition of a. From level 16, the value of b will be 3.The definition a = 1 is not used at all, although it does get compiledbefore the next line replaces it.To actually define a game level, you have to define variables that ofinterest to the game. These variables are introduced in a prescriptresource. Feel free to peek at that resource to see what variables areavailable [during development, the prescript might be empty and theArashi Script file could contain everything].Variables that are prefixed with an 'i' are by convention internalvariables. In the next part of the prescript, these variables areconnected with variables that you should use. For instance, we haveiFlipperCount and FlipperCount. You should use FlipperCount even thoughiFlipperCount is really the variable that the game wants. This conventionallows us to scale or limit the values that can be set. For instance,we should probably limit FlipperCount to a minimum of 0.*/